#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <netcdf.h>
#include <math.h>
#include "wofost.h"
#include "extern.h"
/* Handle errors by printing an error message and exiting with a * non-zero status. */
#define ERR(e) {printf("Error: %s\n", nc_strerror(e)); return 2;}
/* set decimals */
#define roundz(x,d) ((floor(((x)*pow(10,d))+.5))/pow(10,d))

//float Step;
int MeteoYear[METEO_LENGTH], MeteoDay[METEO_LENGTH];
float **Altitude, **AngstA, **AngstB;
float ***Tmin, ***Tmax, ***Radiation, ***Rain, ***Windspeed, ***Vapour,***Tlow;
SimUnit ***Grids;
int Station, Year, **Mask, **Planting_date;
double Longitude[DOMAIN_LENGTH], Latitude[DOMAIN_LENGTH];



int GetMeteoData(Weather* meteo){    int i;    size_t j, k, l;    int retval;    int ncid, lat_dimid, lon_dimid, time_dimid;    int lat_varid, lon_varid, varid;    size_t lat_length, lon_length, time_length;    double minlat, minlon, maxlat, maxlon;    double minlat_tmp, minlon_tmp, maxlat_tmp, maxlon_tmp;    int minyear_tmp, maxyear_tmp, minday_tmp, maxday_tmp;    float ****variable;    float *data;    //float Svap_Tmax, Svap_Tmin, Svap;        // get mask    // open file    if ((retval = nc_open(meteo->mask, NC_NOWRITE, &ncid)))        ERR(retval);        // get lat & lon    if ((retval = nc_inq_dimid(ncid, "lat", &lat_dimid)))        ERR(retval);    if ((retval = nc_inq_dimid(ncid, "lon", &lon_dimid)))        ERR(retval);    if ((retval = nc_inq_dimlen(ncid, lat_dimid, &lat_length)))       ERR(retval);     if ((retval = nc_inq_dimlen(ncid, lon_dimid, &lon_length)))       ERR(retval);    if (lat_length > DOMAIN_LENGTH) {        fprintf(stderr, "Latitude domain %zu is bigger than maximum %d\n",                 lat_length, DOMAIN_LENGTH);        exit(1);     }    if (lon_length > DOMAIN_LENGTH) {        fprintf(stderr, "Longitude domain %zu is bigger than maximum %d\n",                 lon_length, DOMAIN_LENGTH);        exit(1);     }    meteo->nlat = lat_length;    meteo->nlon = lon_length;    if ((retval = nc_inq_varid(ncid, "lat", &lat_varid)))        ERR(retval);    if ((retval = nc_inq_varid(ncid, "lon", &lon_varid)))        ERR(retval);    if ((retval = nc_get_var_double(ncid, lat_varid, &Latitude[0])))       ERR(retval);    if ((retval = nc_get_var_double(ncid, lon_varid, &Longitude[0])))       ERR(retval);        // check lat & lon    minlat = minlon = 9999;    maxlat = maxlon = -9999;    for (j = 0; j < lat_length; j++) {        if (Latitude[j] < minlat) {            minlat = Latitude[j];        }        if (Latitude[j] > maxlat) {            maxlat = Latitude[j];        }    }    for (j = 0; j < lon_length; j++) {        if (Longitude[j] < minlon) {            minlon = Longitude[j];        }        if (Longitude[j] > maxlon) {            maxlon = Longitude[j];        }    }        // allocate mask    if ((retval = nc_inq_varid(ncid, "Band1", &varid)))        ERR(retval);    Mask = malloc(lat_length * sizeof(*Mask));    if(Mask == NULL){        fprintf(stderr, "Could not malloc");        exit(1);     }    for (j = 0; j < lat_length; j++) {        Mask[j] = malloc(lon_length * sizeof(*Mask[j]));        if(Mask[j] == NULL){            fprintf(stderr, "Could not malloc");            exit(1);         }    }    // Fill mask    data = malloc(lon_length * lat_length * sizeof(*data));    if(data == NULL){        fprintf(stderr, "Could not malloc");        exit(1);     }    fprintf(stdout, "Started loading forcing data for MASK\n");    if((retval = nc_get_var_float(ncid, varid, data)))        ERR(retval);    for (j = 0; j < lat_length; j++) {        for (k = 0; k < lon_length; k++) {            Mask[j][k] = data[j * lon_length + k];        }    }    free(data);        // close file    if ((retval = nc_close(ncid)))       ERR(retval);            // get Planting_date    // open file    if ((retval = nc_open(meteo->planting_date, NC_NOWRITE, &ncid)))        ERR(retval);        // get lat & lon    if ((retval = nc_inq_dimid(ncid, "lat", &lat_dimid)))        ERR(retval);    if ((retval = nc_inq_dimid(ncid, "lon", &lon_dimid)))        ERR(retval);    if ((retval = nc_inq_dimlen(ncid, lat_dimid, &lat_length)))       ERR(retval);     if ((retval = nc_inq_dimlen(ncid, lon_dimid, &lon_length)))       ERR(retval);    if (lat_length > DOMAIN_LENGTH) {        fprintf(stderr, "Latitude domain %zu is bigger than maximum %d\n",                 lat_length, DOMAIN_LENGTH);        exit(1);     }    if (lon_length > DOMAIN_LENGTH) {        fprintf(stderr, "Longitude domain %zu is bigger than maximum %d\n",                 lon_length, DOMAIN_LENGTH);        exit(1);     }        if ((retval = nc_inq_varid(ncid, "lat", &lat_varid)))        ERR(retval);    if ((retval = nc_inq_varid(ncid, "lon", &lon_varid)))        ERR(retval);    if ((retval = nc_get_var_double(ncid, lat_varid, &Latitude[0])))       ERR(retval);    if ((retval = nc_get_var_double(ncid, lon_varid, &Longitude[0])))       ERR(retval);        // check lat & lon    minlat_tmp = minlon_tmp = 9999;    maxlat_tmp = maxlon_tmp = -9999;    for (j = 0; j < lat_length; j++) {        if (Latitude[j] < minlat_tmp) {            minlat_tmp = Latitude[j];        }        if (Latitude[j] > maxlat_tmp) {            maxlat_tmp = Latitude[j];        }    }    for (j = 0; j < lon_length; j++) {        if (Longitude[j] < minlon_tmp) {            minlon_tmp = Longitude[j];        }        if (Longitude[j] > maxlon_tmp) {            maxlon_tmp = Longitude[j];        }    }    if(minlat_tmp != minlat || minlon_tmp != minlon ||        maxlat_tmp != maxlat || maxlon_tmp != maxlon) {        fprintf(stderr, "Latitude and/or longitude domain %lf:%lf - %lf:%lf "                            "is different from mask domain %lf:%lf - %lf:%lf\n",                     minlat_tmp, maxlat_tmp, minlon_tmp, maxlon_tmp,                     minlat, maxlat, minlon, maxlon);            exit(1);     }            // allocate planting date    if ((retval = nc_inq_varid(ncid, "Band1", &varid)))        ERR(retval);    Planting_date = malloc(lat_length * sizeof(*Planting_date));    if(Planting_date == NULL){        fprintf(stderr, "Could not malloc");        exit(1);     }    for (j = 0; j < lat_length; j++) {        Planting_date[j] = malloc(lon_length * sizeof(*Planting_date[j]));        if(Planting_date[j] == NULL){            fprintf(stderr, "Could not malloc");            exit(1);         }    }    // Fill planting dates    data = malloc(lon_length * lat_length * sizeof(*data));    if(data == NULL){        fprintf(stderr, "Could not malloc");        exit(1);     }    fprintf(stdout, "Started loading Planting_dates\n");    if((retval = nc_get_var_float(ncid, varid, data)))        ERR(retval);    for (j = 0; j < lat_length; j++) {        for (k = 0; k < lon_length; k++) {                        //Planting_date[j][k] = data[j * lon_length + k];			if (Mask[j][k] >= 1) {                Planting_date[j][k] = data[j * lon_length + k];            } else{                Planting_date[j][k] = -99;            }           }    }    free(data);        // close file    if ((retval = nc_close(ncid)))       ERR(retval);               //Loading forcing data         for (i = 0; i < WEATHER_NTYPES; i++) {        // open file        if ((retval = nc_open(meteo->file[i], NC_NOWRITE, &ncid)))            ERR(retval);                // get lat & lon        if ((retval = nc_inq_dimid(ncid, "lat", &lat_dimid)))            ERR(retval);        if ((retval = nc_inq_dimid(ncid, "lon", &lon_dimid)))            ERR(retval);        if ((retval = nc_inq_dimlen(ncid, lat_dimid, &lat_length)))           ERR(retval);         if ((retval = nc_inq_dimlen(ncid, lon_dimid, &lon_length)))           ERR(retval);        if (lat_length > DOMAIN_LENGTH) {            fprintf(stderr, "Latitude domain %zu is bigger than maximum %d\n",                     lat_length, DOMAIN_LENGTH);            exit(1);         }        if (lon_length > DOMAIN_LENGTH) {            fprintf(stderr, "Longitude domain %zu is bigger than maximum %d\n",                     lon_length, DOMAIN_LENGTH);            exit(1);         }        if ((retval = nc_inq_varid(ncid, "lat", &lat_varid)))            ERR(retval);        if ((retval = nc_inq_varid(ncid, "lon", &lon_varid)))            ERR(retval);        if ((retval = nc_get_var_double(ncid, lat_varid, &Latitude[0])))           ERR(retval);        if ((retval = nc_get_var_double(ncid, lon_varid, &Longitude[0])))           ERR(retval);                // check lat & lon        minlat_tmp = minlon_tmp = 9999;        maxlat_tmp = maxlon_tmp = -9999;        for (j = 0; j < lat_length; j++) {            if (Latitude[j] < minlat_tmp) {                minlat_tmp = Latitude[j];            }            if (Latitude[j] > maxlat_tmp) {                maxlat_tmp = Latitude[j];            }        }        for (j = 0; j < lon_length; j++) {            if (Longitude[j] < minlon_tmp) {                minlon_tmp = Longitude[j];            }            if (Longitude[j] > maxlon_tmp) {                maxlon_tmp = Longitude[j];            }        }        if(minlat_tmp != minlat || minlon_tmp != minlon ||           maxlat_tmp != maxlat || maxlon_tmp != maxlon) {            fprintf(stderr, "Latitude and/or longitude domain %lf:%lf - %lf:%lf "                            "is different from mask domain %lf:%lf - %lf:%lf\n",                     minlat_tmp, maxlat_tmp, minlon_tmp, maxlon_tmp,                     minlat, maxlat, minlon, maxlon);            exit(1);         }                // get time        if ((retval = nc_inq_dimid(ncid, "time", &time_dimid)))            ERR(retval);        if ((retval = nc_inq_dimlen(ncid, time_dimid, &time_length)))           ERR(retval);         if (time_length > METEO_LENGTH) {            fprintf(stderr, "Time %zu is bigger than maximum %d\n",                     time_length, METEO_LENGTH);            exit(1);         }        meteo->ntime = time_length;        // TODO: load time based on actual netcdf values        for (l = 0; l < time_length; l++) {            if (l == 0) {                MeteoYear[l] = meteo->StartYear;                MeteoDay[l] = 1; //assume that the series start January first            } else {                MeteoYear[l] = MeteoYear[l - 1];                MeteoDay[l] = MeteoDay[l - 1] + 1;                                if(MeteoDay[l] > leap_year(MeteoYear[l])) {                    MeteoYear[l] = MeteoYear[l] + 1;                    MeteoDay[l] = 1;                }            }        }                // check time        minyear_tmp = MeteoYear[0];        minday_tmp  = MeteoDay[0];        maxyear_tmp = MeteoYear[time_length - 1];        maxday_tmp  = MeteoDay[time_length - 1];        if(!(minyear_tmp <= meteo->StartYear && minday_tmp == 1) ||           !(maxyear_tmp >= meteo->EndYear) ||           !(maxyear_tmp == meteo->EndYear && maxday_tmp == leap_year(meteo->EndYear)))         {            printf("%d %d\n",maxday_tmp,leap_year(meteo->EndYear));            fprintf(stderr, "Year and/or day domain %d:%d - %d:%d "                     "are different from supplied domain %d:%d - %d:%d\n",                      minyear_tmp, maxyear_tmp, minday_tmp, maxday_tmp,                      meteo->StartYear, meteo->EndYear, 1, leap_year(meteo->EndYear));            exit(1);         }               // allocate variable        if ((retval = nc_inq_varid(ncid, meteo->var[i], &varid)))            ERR(retval);        if (i == WEATHER_TMIN) {            variable = &Tmin;        } else if (i == WEATHER_TMAX) {            variable = &Tmax;        } else if (i == WEATHER_RADIATION) {            variable = &Radiation;        } else if (i == WEATHER_RAIN) {            variable = &Rain;        } else if (i == WEATHER_WINDSPEED) {            variable = &Windspeed;        } else if (i == WEATHER_VAPOUR) {            variable = &Vapour;        }                 (*variable) = malloc(time_length * sizeof(*(*variable)));        if((*variable) == NULL){            fprintf(stderr, "Could not malloc");            exit(1);         }        for (l = 0; l < time_length; l++) {            (*variable)[l] = malloc(lat_length * sizeof(*(*variable)[l]));            if((*variable)[l] == NULL){                fprintf(stderr, "Could not malloc");                exit(1);             }            for (j = 0; j < lat_length; j++) {                (*variable)[l][j] = malloc(lon_length * sizeof(*(*variable)[l][j]));                if((*variable)[l][j] == NULL){                    fprintf(stderr, "Could not malloc");                    exit(1);                 }            }        }                // Fill variable        data = malloc(lon_length * lat_length * time_length * sizeof(*data));        if(data == NULL){            fprintf(stderr, "Could not malloc");            exit(1);         }        fprintf(stdout, "Started loading forcing data for %s\n", meteo->type[i]);        if((retval = nc_get_var_float(ncid, varid, data)))            ERR(retval);        for (l = 0; l < time_length; l++) {            for (j = 0; j < lat_length; j++) {                for (k = 0; k < lon_length; k++) {                    if (Mask[j][k] >= 1) {                                            (*variable)[l][j][k] =                                 data[l * lon_length * lat_length + j * lon_length + k];                                        } else {                                            (*variable)[l][j][k] = -99;                                            }                }                            }                    }        free(data);                // close file        if ((retval = nc_close(ncid)))           ERR(retval);    }        // Varaible to store Tmin //        variable = &Tlow;    (*variable) = malloc(time_length * sizeof(*(*variable)));        if((*variable) == NULL){            fprintf(stderr, "Could not malloc");            exit(1);         }        for (l = 0; l < time_length; l++) {            (*variable)[l] = malloc(lat_length * sizeof(*(*variable)[l]));            if((*variable)[l] == NULL){                fprintf(stderr, "Could not malloc");                exit(1);             }            for (j = 0; j < lat_length; j++) {                (*variable)[l][j] = malloc(lon_length * sizeof(*(*variable)[l][j]));                if((*variable)[l][j] == NULL){                    fprintf(stderr, "Could not malloc");                    exit(1);                 }            }        }        // Add AngstA, AngstB & Altitude    AngstA = malloc(lat_length * sizeof(*AngstA));    AngstB = malloc(lat_length * sizeof(*AngstB));    Altitude = malloc(lat_length * sizeof(*Altitude));    if(AngstA == NULL || AngstB == NULL || Altitude == NULL){        fprintf(stderr, "Could not malloc");        exit(1);     }    for (j = 0; j < lat_length; j++) {        AngstA[j] = malloc(lon_length * sizeof(*AngstA[j]));        AngstB[j] = malloc(lon_length * sizeof(*AngstB[j]));        Altitude[j] = malloc(lon_length * sizeof(*Altitude[j]));        if(AngstA[j] == NULL || AngstB[j] == NULL || Altitude[j] == NULL){            fprintf(stderr, "Could not malloc");            exit(1);         }        for (k = 0; k < lon_length; k++) {            if (Mask[j][k] >= 1) {                AngstA[j][k] = 0.4885 - 0.0052 * Latitude[j];                AngstB[j][k] =  0.1563 + 0.0074 * Latitude[j];                // TODO: temporary needs to be fixed                Altitude[j][k] = 100;            } else {                AngstA[j][k] = -99;                AngstB[j][k] = -99;                // TODO: temporary needs to be fixed                Altitude[j][k] = -99;            }        }    }               // adjust data    for (l = 0; l < time_length; l++) {        for (j = 0; j < lat_length; j++) {            for (k = 0; k < lon_length; k++) {                if (Mask[j][k] >= 1) {                                        Tmin[l][j][k] = roundz(Tmin[l][j][k] - 273.15, 1);                    Tmax[l][j][k] = roundz(Tmax[l][j][k] - 273.15, 1);                    Radiation[l][j][k]  = 1000 * roundz(86.400 * Radiation[l][j][k], 1); // from W/m2 to J/m2/day                    Rain[l][j][k] = roundz(8640 * Rain[l][j][k], 2); // from kg m-2 s-1 sec to cm day-1                    //Rain[l][j][k] = 0;                    Windspeed[l][j][k] = roundz(Windspeed[l][j][k], 1);                                        //Svap_Tmax = 6.108 * exp((17.27 * Tmax[j][k][l]) / (237.3 + Tmax[j][k][l]));                    //Svap_Tmin = 6.108 * exp((17.27 * Tmin[j][k][l]) / (237.3 + Tmin[j][k][l]));                    //Svap = (Svap_Tmax + Svap_Tmin) / 2.;                    //Vapour[j][k][l] = roundz(0.01 * Vapour[j][k][l] * Svap, 2); // from % to hPa                    Vapour[l][j][k] = roundz(Vapour[l][j][k], 1); //  hPa                }            }        }    }            return 1;}